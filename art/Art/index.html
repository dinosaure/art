<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Art (art.Art)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">art</a> &#x00BB; Art</nav><h1>Module <code>Art</code></h1><p>Adaptive Radix Tree in OCaml.</p><p>Implementation of Adaptive Radix Tree (trie), for efficient indexing in memory. Its <i>lookup</i> performance surpasses highly tuned, read-only search trees, while supporting very efficient insertions and deletions as well. ART is very space efficient and solves the problem of excessive worst-case space consumption, which plagues most radix tree, by adaptively choosing compact and efficient data structures for internal nodes. Even though, ART's performance is comparable to hash tables, it maintains the data in sorted order, which enables additional operations like range scan and prefix <i>lookup</i>.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt><dd><p>The type of trees from type <a href="index.html#type-key"><code>key</code></a> to type <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-key"><a href="#type-key" class="anchor"></a><code><span class="keyword">type</span> key</code><code> = <span class="keyword">private</span> string</code></dt><dd><p>The type of the tree keys. A <i>null-terminated</i> <code>string</code>.</p></dd></dl><dl><dt class="spec value" id="val-key"><a href="#val-key" class="anchor"></a><code><span class="keyword">val</span> key : string <span>&#45;&gt;</span> <a href="index.html#type-key">key</a></code></dt></dl><dl><dt class="spec external" id="val-unsafe_key"><a href="#val-unsafe_key" class="anchor"></a><code><span class="keyword">val</span> unsafe_key : string <span>&#45;&gt;</span> <a href="index.html#type-key">key</a></code></dt></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>make ()</code> creates a new, empty tree.</p></dd></dl><dl><dt class="spec value" id="val-insert"><a href="#val-insert" class="anchor"></a><code><span class="keyword">val</span> insert : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>insert t k v</code> replaces the current binding of <code>k</code> in <code>t</code> by a binding of <code>k</code> to <code>v</code>. If <code>k</code> is unbound in <code>t</code>, a binding of <code>k</code> to <code>v</code> is added to <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find x t</code> returns the current binding of <code>x</code> in <code>t</code>, or raises <code>Not_found</code> if no such binding exists.</p></dd></dl><dl><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val</span> find_opt : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>find_opt x t</code> returns <code>Some v</code> if the current value of <code>x</code> in <code>t</code> is <code>v</code>, or <code>None</code> if no binding for <code>x</code> exists.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><span class="type-var">'a</span> Fmt.t</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> Fmt.t</span></code></dt><dt class="spec value" id="val-minimum"><a href="#val-minimum" class="anchor"></a><code><span class="keyword">val</span> minimum : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> * <span class="type-var">'a</span></code></dt><dd><p>Return the binding with the smallest <a href="index.html#type-key"><code>key</code></a> in a given tree or raise <code>Invalid_argument</code> if the tree is empty.</p></dd></dl><dl><dt class="spec value" id="val-maximum"><a href="#val-maximum" class="anchor"></a><code><span class="keyword">val</span> maximum : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> * <span class="type-var">'a</span></code></dt><dd><p>Same as <a href="index.html#val-minimum"><code>minimum</code></a>, but returns the binding with the largest <a href="index.html#type-key"><code>key</code></a> in the given tree.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>remove t k</code> removes the current binding of <code>k</code> in <code>t</code>. It raises <code>Not_found</code> if <code>k</code> is not bound in <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>f:<span>(<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'acc</span></code></dt><dd><p><code>iter ~f a t</code> computes <code>(f kN dN ... (f k1 d1 a) ...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>t</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p></dd></dl><dl><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span><span>(<a href="index.html#type-key">key</a> * <span class="type-var">'a</span>)</span> Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Build a tree from the given bindings.</p></dd></dl><dl><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-key">key</a> * <span class="type-var">'a</span>)</span> Stdlib.Seq.t</span></code></dt><dd><p>Iterate on the whole map, in increasing order of keys.</p></dd></dl></div></body></html>