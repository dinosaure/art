<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Art (art.Art)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">art</a> &#x00BB; Art</nav><header class="odoc-preamble"><h1>Module <code><span>Art</span></code></h1><p>Adaptive Radix Tree in OCaml.</p><p>Implementation of Adaptive Radix Tree (trie), for efficient indexing in memory. Its <i>lookup</i> performance surpasses highly tuned, read-only search trees, while supporting very efficient insertions and deletions as well. ART is very space efficient and solves the problem of excessive worst-case space consumption, which plagues most radix tree, by adaptively choosing compact and efficient data structures for internal nodes. Even though, ART's performance is comparable to hash tables, it maintains the data in sorted order, which enables additional operations like range scan and prefix <i>lookup</i>.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>The type of trees from type <a href="#type-key"><code>key</code></a> to type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-key" class="anchored"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> key</span><span> = <span class="keyword">private</span> string</span></code></div><div class="spec-doc"><p>The type of the tree keys. A <i>null-terminated</i> <code>string</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-key" class="anchored"><a href="#val-key" class="anchor"></a><code><span><span class="keyword">val</span> key : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a></span></code></div></div><div class="odoc-spec"><div class="spec value external" id="val-unsafe_key" class="anchored"><a href="#val-unsafe_key" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_key : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>make ()</code> creates a new, empty tree.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-insert" class="anchored"><a href="#val-insert" class="anchor"></a><code><span><span class="keyword">val</span> insert : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>insert t k v</code> replaces the current binding of <code>k</code> in <code>t</code> by a binding of <code>k</code> to <code>v</code>. If <code>k</code> is unbound in <code>t</code>, a binding of <code>k</code> to <code>v</code> is added to <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find x t</code> returns the current binding of <code>x</code> in <code>t</code>, or raises <code>Not_found</code> if no such binding exists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_opt" class="anchored"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find_opt x t</code> returns <code>Some v</code> if the current value of <code>x</code> in <code>t</code> is <code>v</code>, or <code>None</code> if no binding for <code>x</code> exists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Fmt</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty tree</code> returns <code>true</code> if <code>tree</code> is empty. Otherwise, it returns <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-minimum" class="anchored"><a href="#val-minimum" class="anchor"></a><code><span><span class="keyword">val</span> minimum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return the binding with the smallest <a href="#type-key"><code>key</code></a> in a given tree or raise <code>Invalid_argument</code> if the tree is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-maximum" class="anchored"><a href="#val-maximum" class="anchor"></a><code><span><span class="keyword">val</span> maximum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-minimum"><code>minimum</code></a>, but returns the binding with the largest <a href="#type-key"><code>key</code></a> in the given tree.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove t k</code> removes the current binding of <code>k</code> in <code>t</code>. It raises <code>Not_found</code> if <code>k</code> is not bound in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span>f:<span>( <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>iter ~f a t</code> computes <code>(f kN dN ... (f k1 d1 a) ...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>t</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Build a tree from the given bindings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seq" class="anchored"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Iterate on the whole map, in increasing order of keys.</p></div></div></div></body></html>